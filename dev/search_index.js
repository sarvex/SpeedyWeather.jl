var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-and-type-index","page":"Function and type index","title":"Function and type index","text":"","category":"section"},{"location":"functions/#Parameters-and-constants","page":"Function and type index","title":"Parameters and constants","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Parameters\nSpeedyWeather.Constants","category":"page"},{"location":"functions/#SpeedyWeather.Parameters","page":"Function and type index","title":"SpeedyWeather.Parameters","text":"P = Parameters(kwargs...)\n\nA struct to hold all model parameters that may be changed by the user. The struct uses keywords such that default values can be changed at creation. The default values of the keywords define the default model setup.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.Constants","page":"Function and type index","title":"SpeedyWeather.Constants","text":"Struct holding the parameters needed at runtime in number format NF.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Boundaries-and-boundary-conditions","page":"Function and type index","title":"Boundaries and boundary conditions","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Boundaries","category":"page"},{"location":"functions/#SpeedyWeather.Boundaries","page":"Function and type index","title":"SpeedyWeather.Boundaries","text":"Struct that holds the boundary arrays in grid-point space     geopotsurf     ::Array{Complex{NF},2}  # spectral surface geopotential (orography * gravity) [m^2/s^2]     landseamask    ::Array{NF,2}           # land-sea mask, grid-point     albedo          ::Array{NF,2}           # annual mean surface albedo, grid-point\n\n\n\n\n\n","category":"type"},{"location":"functions/#Spherical-harmonic-transform","page":"Function and type index","title":"Spherical harmonic transform","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.GeoSpectral\nSpeedyWeather.SpectralTransform\nSpeedyWeather.spectral\nSpeedyWeather.spectral!\nSpeedyWeather.gridded\nSpeedyWeather.gridded!\nSpeedyWeather.triangular_truncation\nSpeedyWeather.roundup_fft\nSpeedyWeather.spectral_truncation\nSpeedyWeather.spectral_truncation!\nSpeedyWeather.spectral_interpolation!\nSpeedyWeather.get_legendre_polynomials!\nSpeedyWeather.∇²!\nSpeedyWeather.∇²\nSpeedyWeather.∇⁻²!\nSpeedyWeather.∇⁻²\nSpeedyWeather.gradient_latitude!\nSpeedyWeather.gradient_latitude\nSpeedyWeather.gradient_longitude!\nSpeedyWeather.gradient_longitude\nSpeedyWeather.divergence!\nSpeedyWeather.curl!\nSpeedyWeather._divergence!\nSpeedyWeather.curl_div!\nSpeedyWeather.UV_from_vordiv!\nSpeedyWeather.UV_from_vor!\nSpeedyWeather.ϵlm\nSpeedyWeather.get_recursion_factors","category":"page"},{"location":"functions/#SpeedyWeather.SpectralTransform","page":"Function and type index","title":"SpeedyWeather.SpectralTransform","text":"SpectralTransform struct that contains all parameters and preallocated arrays for the spectral transform.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.spectral","page":"Function and type index","title":"SpeedyWeather.spectral","text":"alms = spectral(map)\n\nForward spectral transform (grid to spectral space) from the gridded field map on a regular Gaussian grid (with Gaussian latitudes) into the spectral coefficients of the Legendre polynomials alms. Based on the size of map this function retrieves the corresponding spectral resolution via triangular truncation and sets up a SpectralTransform struct S to execute spectral(map,S).\n\n\n\n\n\nalms = spectral(map,S)\n\nForward spectral transform (grid to spectral space) from the gridded field map on a regular Gaussian grid (with Gaussian latitudes) and the SpectralTransform struct S into the spectral coefficients of the Legendre polynomials alms. This function allocates alms and executes spectral!(alms,map,S).\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.spectral!","page":"Function and type index","title":"SpeedyWeather.spectral!","text":"spectral!(alms,map,S)\n\nForward spectral transform (grid to spectral space) from the gridded field map on a regular Gaussian grid (with Gaussian latitudes). Uses a planned real-valued Fast Fourier Transform in the zonal direction, and a Legendre Transform in the meridional direction exploiting symmetries.Either recomputes the Legendre polynomials Λ for each latitude on one hemisphere or uses precomputed polynomials from S.Λs, depending on S.recompute_legendre. Further uses Legendre weights on Gaussian latitudes for a leakage-free transform.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.gridded","page":"Function and type index","title":"SpeedyWeather.gridded","text":"map = gridded(alms)\n\nBackward or inverse spectral transform (spectral to grid space) from coefficients alms. Based on the size of alms the corresponding grid space resolution is retrieved based on triangular truncation and a  SpectralTransform struct S is allocated to execute gridded(alms,S).\n\n\n\n\n\nmap = gridded(alms,S)\n\nBackward or inverse spectral transform (spectral to grid space) from coefficients alms and the  SpectralTransform struct S. Allocates the output map with Gaussian latitudes and executes gridded!(map,alms,S).\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.gridded!","page":"Function and type index","title":"SpeedyWeather.gridded!","text":"gridded!(map,alms,S)\n\nBackward or inverse spectral transform (spectral to grid space) from coefficients alms and SpectralTransform struct S into the preallocated output map. Uses a planned inverse Fast Fourier Transform for efficiency in the zonal direction and a Legendre Transform in the meridional direction exploiting symmetries for effciency. Either recomputes the Legendre polynomials to save memory, or uses precomputed polynomials from S depending on S.recompute_legendre.\n\n\n\n\n\ngridded!(   diagn::DiagnosticVariables{NF}, # all diagnostic variables\n            progn::PrognosticVariables{NF}, # all prognostic variables\n            M::BarotropicModel,             # everything that's constant\n            lf::Int=1                       # leapfrog index\n            ) where NF\n\nPropagate the spectral state of the prognostic variables progn to the diagnostic variables in diagn for the barotropic vorticity model. Updates grid vorticity, spectral stream function and spectral and grid velocities u,v.\n\n\n\n\n\ngridded!(   diagn::DiagnosticVariables{NF}, # all diagnostic variables\n            progn::PrognosticVariables{NF}, # all prognostic variables\n            M::ShallowWaterModel,           # everything that's constant\n            lf::Int=1                       # leapfrog index\n            ) where NF\n\nPropagate the spectral state of the prognostic variables progn to the diagnostic variables in diagn for the shallow water model. Updates grid vorticity, grid divergence, grid interface displacement (pres_grid) and the velocities U,V (scaled by cos(lat)).\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.triangular_truncation","page":"Function and type index","title":"SpeedyWeather.triangular_truncation","text":"tri_trunc = triangular_truncation(;trunc::Int=0,nlon::Int=0,nlat::Int=0)\n\nReturns a tri_trunc::TriangularTruncation struct, that contains the spectral truncation trunc, and the grid sizes nlon,nlat that satisfy the triangular truncation constraints. Provide either trunc, nlon, or nlat but not a combination. If trunc is provided, nlon will be easily Fast Fourier-transformable, as determined in roundup_fft. If nlon or nlat are provided, tri_trunc.trunc is the largest spectral truncation that satisfies the constraints.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.roundup_fft","page":"Function and type index","title":"SpeedyWeather.roundup_fft","text":"m = roundup_fft(n::Int;\n                small_primes::Vector{Int}=[2,3,5])\n\nReturns an integer m >= n with only small prime factors 2, 3, 5 (default, others can be specified with the keyword argument small_primes) to obtain an efficiently fourier-transformable number of longitudes, m = 2^i * 3^j * 5^k >= n, with i,j,k >=0.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.spectral_truncation","page":"Function and type index","title":"SpeedyWeather.spectral_truncation","text":"alms_trunc = spectral_truncation(alms,trunc)\n\nReturns a spectral coefficient matrix alms_trunc that is truncated from alms to the size (trunc+1)^2. alms_trunc only contains those coefficient of alms for which m,l <= trunc, and l>=m are zero anyway. If trunc is larger than the implicit truncation in alms obtained from its size than spectral_interpolation is automatically called instead, returning alms_interp, a coefficient matrix that is larger than alms with padded zero coefficients. Also works with higher dimensional arrays, but truncation is only applied to the first two dimensions.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.spectral_truncation!","page":"Function and type index","title":"SpeedyWeather.spectral_truncation!","text":"spectral_truncation!(alms,ltrunc,mtrunc)\n\nTruncate spectral coefficients alms in-place by setting (a) the upper right triangle to zero and (b) all coefficients for which the degree l is larger than the truncation ltrunc or order m larger than the truncaction mtrunc.\n\n\n\n\n\nspectral_truncation!(alms,trunc)\n\nTruncate spectral coefficients alms in-place by setting (a) the upper right triangle to zero and (b) all coefficients for which the degree l is larger than the truncation trunc.\n\n\n\n\n\nspectral_truncation!(alms)\n\nTruncate spectral coefficients alms in-place by setting the upper right triangle to zero. This is to enforce that all coefficients for which the degree l is larger than order m are zero.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.get_legendre_polynomials!","page":"Function and type index","title":"SpeedyWeather.get_legendre_polynomials!","text":"Λ_ilat = get_legendre_polynomials!(Λ,Λs,ilat,cos_colat,recompute_legendre)\n\nBase on recompute_legendre (true/false) this function either updates the Legendre polynomials Λ for a given latitude ilat, cos_colat by recomputation (recompute_legendre == true), or Λ is changed by creating a view on the corresponding latitude in precomputed Λs. Recomputation takes usually longer, but precomputation requires a large amount of memory for high resolution.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.∇²!","page":"Function and type index","title":"SpeedyWeather.∇²!","text":"∇²!(    ∇⁻²alms::AbstractMatrix{Complex},\n        alms::AbstractMatrix{Complex},\n        S::SpectralTransform)\n\nLaplace operator ∇² applied to the spectral coefficients alms in spherical coordinates. The radius R is omitted in the eigenvalues which are precomputed in S. ∇²! is the in-place version which directly stores the output in the first argument ∇²alms. The spherical Laplace operator is generally\n\n∇⁻²alms = alms*(-l(l+1))/R²\n\nwith the degree l (0-based) of the Legendre polynomial.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.divergence!","page":"Function and type index","title":"SpeedyWeather.divergence!","text":"divergence!(div::LowerTriangularMatrix,\n            u::LowerTriangularMatrix,\n            v::LowerTriangularMatrix,\n            S::SpectralTransform{NF};\n            flipsign::Bool=false,\n            add::Bool=false,\n            )\n\nDivergence of a vector u,v written into div, div = ∇⋅(u,v).  u,v are expected to have a 1/coslat-scaling included, then div is not scaled. flipsign option calculates -∇⋅(u,v) instead. add option calculates div += ∇⋅(u,v) instead. flipsign and add can be combined. This functions only creates the kernel and calls the generic divergence function _divergence! subsequently.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.curl!","page":"Function and type index","title":"SpeedyWeather.curl!","text":"curl!(  curl::LowerTriangularMatrix,\n        u::LowerTriangularMatrix,\n        v::LowerTriangularMatrix,\n        S::SpectralTransform;\n        flipsign::Bool=false,\n        add::Bool=false,\n        )\n\nCurl of a vector u,v written into curl, curl = ∇×(u,v). u,v are expected to have a 1/coslat-scaling included, then curl is not scaled. flipsign option calculates -∇×(u,v) instead. add option calculates curl += ∇×(u,v) instead. flipsign and add can be combined. This functions only creates the kernel and calls the generic divergence function _divergence! subsequently with flipped u,v -> v,u for the curl.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather._divergence!","page":"Function and type index","title":"SpeedyWeather._divergence!","text":"_divergence!(   kernel,\n                div::AbstractMatrix{Complex{NF}},\n                u::AbstractMatrix{Complex{NF}},\n                v::AbstractMatrix{Complex{NF}},\n                S::SpectralTransform{NF}\n                ) where {NF<:AbstractFloat}\n\nGeneric divergence function of vector u,v that writes into the output into div. Generic as it uses the kernel kernel such that curl, div, add or flipsign options are provided through kernel, but otherwise a single function is used.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.UV_from_vordiv!","page":"Function and type index","title":"SpeedyWeather.UV_from_vordiv!","text":"UV_from_vordiv!(U::AbstractMatrix{Complex{NF}},\n                V::AbstractMatrix{Complex{NF}},\n                vor::AbstractMatrix{Complex{NF}},\n                div::AbstractMatrix{Complex{NF}},\n                S::SpectralTransform{NF}\n                ) where {NF<:AbstractFloat}\n\nGet U,V (=(u,v)*coslat) from vorticity ζ and divergence D in spectral space. Two operations are combined into a single linear operation. First, invert the spherical Laplace ∇² operator to get stream function from vorticity and velocity potential from divergence. Then compute zonal and meridional gradients to get U,V.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.UV_from_vor!","page":"Function and type index","title":"SpeedyWeather.UV_from_vor!","text":"UV_from_vor!(   U::AbstractMatrix{Complex{NF}},\n                V::AbstractMatrix{Complex{NF}},\n                vor::AbstractMatrix{Complex{NF}},\n                S::SpectralTransform{NF}\n                ) where {NF<:AbstractFloat}\n\nGet U,V (=(u,v)*coslat) from vorticity ζ spectral space (divergence D=0) Two operations are combined into a single linear operation. First, invert the spherical Laplace ∇² operator to get stream function from vorticity. Then compute zonal and meridional gradients to get U,V.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.ϵlm","page":"Function and type index","title":"SpeedyWeather.ϵlm","text":"ϵ = ϵ(NF,l,m)\n\nRecursion factors ϵ as a function of degree l and order m (0-based) of the spherical harmonics. ϵ(l,m) = sqrt((l^2-m^2)/(4*l^2-1)) and then converted to number format NF.\n\n\n\n\n\nϵ = ϵ(l,m)\n\nRecursion factors ϵ as a function of degree l and order m (0-based) of the spherical harmonics. ϵ(l,m) = sqrt((l^2-m^2)/(4*l^2-1)) with default number format Float64.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.get_recursion_factors","page":"Function and type index","title":"SpeedyWeather.get_recursion_factors","text":"get_recursion_factors(  ::Type{NF}, # number format NF\n                        lmax::Int,  # max degree l of spherical harmonics (0-based here)\n                        mmax::Int   # max order m of spherical harmonics\n                        ) where {NF<:AbstractFloat}\n\nReturns a matrix of recursion factors ϵ up to degree lmax and order mmax of number format NF.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Dynamics","page":"Function and type index","title":"Dynamics","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.bernoulli_potential!\nSpeedyWeather.volume_flux_divergence!\nSpeedyWeather.vorticity_fluxes!\nSpeedyWeather.vorticity_flux_curl!\nSpeedyWeather.vorticity_flux_divergence!","category":"page"},{"location":"functions/#SpeedyWeather.bernoulli_potential!","page":"Function and type index","title":"SpeedyWeather.bernoulli_potential!","text":"bernoulli_potential!(   D::DiagnosticVariables{NF}, # all diagnostic variables   \n                        GS::GeoSpectral{NF},        # struct with geometry and spectral transform\n                        g::Real                     # gravity\n                        ) where {NF<:AbstractFloat}\n\nComputes the Laplace operator ∇² of the Bernoulli potential B in spectral space. First, computes the Bernoulli potential on the grid, then transforms to spectral space and takes the Laplace operator.\n\n\n\n\n\nbernoulli_potential!(   B::AbstractMatrix{NF},  # Output: Bernoulli potential B = 1/2*(u^2+v^2)+g*η\n                        u::AbstractMatrix{NF},  # zonal velocity\n                        v::AbstractMatrix{NF},  # meridional velocity\n                        η::AbstractMatrix{NF},  # interface displacement\n                        g::Real                 # gravity\n                        ) where {NF<:AbstractFloat}\n\nComputes the Bernoulli potential 1/2(u^2 + v^2) + gη in grid-point space.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.volume_flux_divergence!","page":"Function and type index","title":"SpeedyWeather.volume_flux_divergence!","text":"volume_fluxes!( D::DiagnosticVariables{NF},\n                G::Geometry{NF},\n                S::SpectralTransform{NF},\n                B::Boundaries,\n                H₀::Real                    # layer thickness\n                ) where {NF<:AbstractFloat}\n\nComputes the (negative) divergence of the volume fluxes uh,vh for the continuity equation, -∇⋅(uh,vh)\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.vorticity_fluxes!","page":"Function and type index","title":"SpeedyWeather.vorticity_fluxes!","text":"vorticity_fluxes!(  uω_coslat⁻¹::AbstractMatrix{NF},    # Output: u*(ζ+f)/coslat in grid space\n                    vω_coslat⁻¹::AbstractMatrix{NF},    # Output: v*(ζ+f)/coslat in grid space\n                    U::AbstractMatrix{NF},              # Input: u*coslat in grid space\n                    V::AbstractMatrix{NF},              # Input: v*coslat in grid space\n                    vor::AbstractMatrix{NF},            # Input: relative vorticity ζ in grid space       \n                    G::Geometry{NF}                     # struct with precomputed geometry arrays\n                    ) where {NF<:AbstractFloat}         # number format NF\n\nCompute the vorticity fluxes (u,v)*(ζ+f)/coslat in grid-point space from U,V and vorticity ζ.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.vorticity_flux_curl!","page":"Function and type index","title":"SpeedyWeather.vorticity_flux_curl!","text":"vorticity_flux_curl!(   D::DiagnosticVariablesLayer,\n                        S::SpectralTransform,\n                        )\n\nCompute the curl of the vorticity fluxes ∇×(uω,vω) and store in divergence tendency. Requires vorticity_fluxes! to have been calculated already.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.vorticity_flux_divergence!","page":"Function and type index","title":"SpeedyWeather.vorticity_flux_divergence!","text":"vorticity_flux_divergence!( D::DiagnosticVariables{NF}, # all diagnostic variables   \n                            G::GeoSpectral{NF}          # struct with geometry and spectral transform\n                            ) where {NF<:AbstractFloat}\n\nCompute the vorticity advection as the (negative) divergence of the vorticity fluxes -∇⋅(uv(ζ+f)). First, compute the uv(ζ+f), then transform to spectral space and take the divergence and flip the sign.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Geometry","page":"Function and type index","title":"Geometry","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Geometry\nSpeedyWeather.vertical_coordinates\nSpeedyWeather.GenLogisticCoefs\nSpeedyWeather.generalised_logistic","category":"page"},{"location":"functions/#SpeedyWeather.Geometry","page":"Function and type index","title":"SpeedyWeather.Geometry","text":"Geometry struct containing parameters and arrays describing the Gaussian grid and the vertical levels. NF is the number format used for the precomputed constants.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.vertical_coordinates","page":"Function and type index","title":"SpeedyWeather.vertical_coordinates","text":"σ_levels_half = vertical_coordinates(P::Parameters)\n\nVertical sigma coordinates defined by their nlev+1 half levels σ_levels_half. Sigma coordinates are fraction of surface pressure (p/p0) and are sorted from top (stratosphere) to bottom (surface). The first half level is at 0 the last at 1. Evaluate a generalised logistic function with coefficients in P for the distribution of values in between. Default coefficients follow the L31 configuration historically used at ECMWF.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.GenLogisticCoefs","page":"Function and type index","title":"SpeedyWeather.GenLogisticCoefs","text":"Coefficients of the generalised logistic function to describe the vertical coordinate. Default coefficients A,K,C,Q,B,M,ν are fitted to the old L31 configuration at ECMWF. See geometry.jl and function vertical_coordinate for more informaiton.\n\nFollowing the notation of https://en.wikipedia.org/wiki/Generalisedlogisticfunction (Dec 15 2021).\n\nChange default parameters for more/fewer levels in the stratosphere vs troposphere vs boundary layer.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.generalised_logistic","page":"Function and type index","title":"SpeedyWeather.generalised_logistic","text":"Generalised logistic function based on the coefficients in coefs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Time-stepping","page":"Function and type index","title":"Time stepping","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.time_stepping!\nSpeedyWeather.timestep!\nSpeedyWeather.first_timesteps!\nSpeedyWeather.leapfrog!","category":"page"},{"location":"functions/#SpeedyWeather.time_stepping!","page":"Function and type index","title":"SpeedyWeather.time_stepping!","text":"time_stepping!( progn::PrognosticVariables,     # all prognostic variables\n                diagn::DiagnosticVariables,     # all pre-allocated diagnostic variables\n                M::ModelSetup                   # all precalculated structs\n                )\n\nMain time loop that that initialises output and feedback, loops over all time steps and calls the output and feedback functions.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.timestep!","page":"Function and type index","title":"SpeedyWeather.timestep!","text":"timestep!(  progn::PrognosticVariables{NF}, # all prognostic variables\n            diagn::DiagnosticVariables{NF}, # all pre-allocated diagnostic variables\n            dt::Real,                       # time step (mostly =2Δt, but for init steps =Δt,Δt/2)\n            M::PrimitiveEquationModel,      # everything that's constant at runtime\n            lf1::Int=2,                     # leapfrog index 1 (dis/enables Robert+William's filter)\n            lf2::Int=2                      # leapfrog index 2 (time step used for tendencies)\n            ) where {NF<:AbstractFloat}\n\nCalculate a single time step for the primitive equation model of SpeedyWeather.jl \n\n\n\n\n\ntimestep!(  progn::PrognosticVariables{NF}, # all prognostic variables\n            diagn::DiagnosticVariables{NF}, # all pre-allocated diagnostic variables\n            dt::Real,                       # time step (mostly =2Δt, but for init steps =Δt,Δt/2)\n            M::ShallowWaterModel,           # everything that's constant at runtime\n            lf1::Int=2,                     # leapfrog index 1 (dis/enables Robert+William's filter)\n            lf2::Int=2                      # leapfrog index 2 (time step used for tendencies)\n            ) where {NF<:AbstractFloat}\n\nCalculate a single time step for the shallow water model of SpeedyWeather.jl \n\n\n\n\n\ntimestep!(  progn::PrognosticVariables,     # all prognostic variables\n            diagn::DiagnosticVariables,     # all pre-allocated diagnostic variables\n            dt::Real,                       # time step (mostly =2Δt, but for init steps =Δt,Δt/2)\n            lf1::Int=2,                     # leapfrog index 1 (dis/enables Robert+William's filter)\n            lf2::Int=2,                     # leapfrog index 2 (time step used for tendencies)\n            M::BarotropicModel,             # everything that's constant at runtime\n            )\n\nCalculate a single time step for the barotropic vorticity equation model of SpeedyWeather.jl \n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.first_timesteps!","page":"Function and type index","title":"SpeedyWeather.first_timesteps!","text":"first_timesteps!(   progn::PrognosticVariables, # all prognostic variables\n                    diagn::DiagnosticVariables, # all pre-allocated diagnostic variables\n                    M::ModelSetup,              # everything that is constant at runtime\n                    feedback::Feedback          # feedback struct\n                    )\n\nPerforms the first two initial time steps (Euler forward, unfiltered leapfrog) to populate the prognostic variables with two time steps (t=0,Δt) that can then be used in the normal leap frogging.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.leapfrog!","page":"Function and type index","title":"SpeedyWeather.leapfrog!","text":"leapfrog!(  A_old::LowerTriangularMatrix{Complex{NF}},      # prognostic variable at t\n            A_new::LowerTriangularMatrix{Complex{NF}},      # prognostic variable at t+dt\n            tendency::LowerTriangularMatrix{Complex{NF}},   # tendency (dynamics+physics) of A\n            dt::Real,                                       # time step (=2Δt, but for init steps =Δt,Δt/2)\n            lf::Int=2,                                      # leapfrog index to dis/enable William's filter\n            C::Constants{NF},                               # struct with constants used at runtime\n            ) where {NF<:AbstractFloat}                     # number format NF\n\nPerforms one leapfrog time step with (lf=2) or without (lf=1) Robert+William's filter (see William (2009), Montly Weather Review, Eq. 7-9).\n\n\n\n\n\n","category":"function"},{"location":"conventions/#Style-and-convention-guide","page":"Style and convention guide","title":"Style and convention guide","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"In SpeedyWeather.jl we've been following the several conventions that are documented here.","category":"page"},{"location":"conventions/#Variable-naming","page":"Style and convention guide","title":"Variable naming","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"The prognostic variables in spectral space are called","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    vor         # Vorticity of horizontal wind field\n    div         # Divergence of horizontal wind field\n    temp        # Absolute temperature [K]\n    pres_surf   # Logarithm of surface pressure [log(Pa)]\n    humid       # Specific humidity [g/kg]","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"their transforms into grid-point space get a _grid suffix, their tendencies a _tend suffix. Further derived diagnostic dynamic variables are","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    u\n    v\n    geopot\n    ...","category":"page"},{"location":"conventions/#Preallocation","page":"Style and convention guide","title":"Preallocation","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"All arrays representing variables are preallocated and grouped into two structs","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    Prog::PrognosticVariables\n    Diag::DiagnosticVariables","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"The Diag struct contains further structs which represent the grid-point transformations of the prognostic variables and their tendencies.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    gridvars::GridVariables\n    tendencies::Tendencies\n    ...","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Constant arrays are grouped into several structs","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Boundaries","category":"page"},{"location":"conventions/#Julian-conventions","page":"Style and convention guide","title":"Julian conventions","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"We follow Julia's style guide and highlight here some important aspects of it.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Bang (!) convention. A function func does not change its input arguments, however, func! does.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Hence, func! is often the in-place version of func, avoiding as much memory allocation as possible and often changing its first argument, e.g. func!(out,in) so that argument in is used to calculate out which has been preallocated before function call.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Number format flexibility. Numeric literals such as 2.0 or 1/3 are only used in the model setup","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"but avoided throughout the code to obtain a fully number format-flexible package using the number format NF as a compile-time variable throughout the code. This often leads to overly specific code whereas a Real would generally suffice. However, this is done to avoid any implicit type conversions.","category":"page"},{"location":"dynamical_core/#Dynamical-core","page":"Dynamical core","title":"Dynamical core","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"A mathematical and implementation-specific description of the dynamical core used in SpeedyWeather.jl. We start by describing the barotropic vorticity equations which is one set of equations that SpeedyWeather.jl can solve (see How to run SpeedyWeather.jl) as many details therein also apply to the Shallow water equations and Primitive equations explained thereafter.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The dynamical core presented here largely follows the idealized models with spectral dynamics developed at the Geophysical Fluid Dynamics Laboratory[1]: A barotropic vorticity model[2], a shallow water model [3] and a primitive equation model[4]. ","category":"page"},{"location":"dynamical_core/#Barotropic-vorticity-equation","page":"Dynamical core","title":"Barotropic vorticity equation","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The barotropic vorticity equation is the prognostic equation that describes the time evolution of relative vorticity zeta with advection, Coriolis force and diffusion in a single global layer.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"fracpartial zetapartial t + nabla cdot (mathbfu(zeta + f)) = nunabla^2nzeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with time t, velocity vector mathbfu = (uv), Coriolis parameter f and hyperdiffusion nunabla^2nzeta (see Horizontal diffusion). Starting with some relative vorticity zeta, the Laplacian is inverted to obtain the stream function Psi","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Psi = nabla^-2zeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The zonal velocity u and meridional velocity v are then the (negative) meridional gradient and zonal gradient of Psi","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\nu = -frac1R fracpartial Psipartial theta \nv = frac1Rcos(theta) fracpartial Psipartial phi \nendaligned","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"which is described in Gradients in spectral space.","category":"page"},{"location":"dynamical_core/#Algorithm","page":"Dynamical core","title":"Algorithm","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"We briefly outline the algorithm that SpeedyWeather.jl uses in order to integrate the barotropic vorticity equation","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Start with initial conditions of zeta_lm in spectral space\nUse zeta_lm to\nInvert the Laplacian to obtain the stream function Psi_lm in spectral space\nTransform zeta_lm to zeta in grid-point space\nUse Psi_lm to\nobtain zonal velocity (cos(theta)u)_lm through a Meridional derivative\nobtain meridional velocity (cos(theta)v)_lm through a Zonal derivative\nTransform zonal and meridional velocity (cos(theta)u)_lm, (cos(theta)v)_lm to grid-point space and unscale the cos(theta) factor to obtain uv.\nMultiply uv with zeta+f in grid-point space\nTransform u(zeta + f) and v(zeta+f) to spectral space\nCompute the divergence of (mathbfu(zeta + f))_lm in spectral space through a Meridional derivative and Zonal derivative which will be the tendency of zeta_lm\nCompute the Horizontal diffusion based on that tendency\nCompute a leapfrog time step as described in Time integration\nRepeat from 1.","category":"page"},{"location":"dynamical_core/#Shallow-water-equations","page":"Dynamical core","title":"Shallow water equations","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\nfracpartial zetapartial t + nabla cdot (mathbfu(zeta + f)) = nunabla^2nzeta \nfracpartial mathcalDpartial t - nabla times (mathbfu(zeta + f)) = -nabla^2(tfrac12(u^2 + v^2) + geta) + nunabla^2nmathcalD \nfracpartial etapartial t + nabla cdot (mathbfuh) = 0\nendaligned","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"more to come","category":"page"},{"location":"dynamical_core/#Primitive-equations","page":"Dynamical core","title":"Primitive equations","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The primitive equations solved by SpeedyWeather.jl are","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\npartial_t u =  \npartial_t v =  \npartial_t T =   \npartial_t Q = \nendaligned","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"more to come","category":"page"},{"location":"dynamical_core/#Horizontal-diffusion","page":"Dynamical core","title":"Horizontal diffusion","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In SpeedyWeather.jl we use hyerdiffusion through an n-th power Laplacian nabla^2n (hyper when n1) which can be implemented as a multiplication of the spectral coefficients Psi_lm with (-l(l+1))^nR^-2n (see spectral Laplacian) It is therefore computationally not more expensive to apply hyperdiffusion over diffusion as the (-l(l+1))^nR^-2n can be precomputed.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In SpeedyWeather.jl the diffusion is applied implicitly. For that, consider a leapfrog scheme with time step Delta t of variable zeta to obtain from time steps i-1 and i, the next time step i+1","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t dzeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with dzeta being some tendency evaluated from zeta_i. Now we want to add a diffusion term -nu nabla^2nzeta with viscosity nu, wich however, is implicitly calculated from zeta_i+1, then","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t (dzeta - nunabla^2nzeta_i+1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"As the application of nunabla^2n is, for every spectral mode, equivalent to a multiplication of a constant, we can rewrite this to","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = fraczeta_i-1 + 2Delta t dzeta1 + 2Delta nunabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and expand the numerator to","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t fracdzeta - nunabla^2nzeta_i-11+2Delta t nu nabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Hence the diffusion can be applied implicitly by updating the tendency dzeta as","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"dzeta to fracdzeta - nunabla^2nzeta_i-11+2Delta t nu nabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"which only depends on zeta_i-1. Now let D_textexplicit = nunabla^2n be the explicit part and D_textimplicit = 1 + 2Delta t nunabla^2n the implicit part. Both parts can be precomputed and are only an element-wise multiplication in spectral space. For every spectral harmonic lm we do","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"dzeta to D_textimplicit^-1(dzeta - D_textexplicitzeta_i-1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Hence 2 multiplications and 1 subtraction with precomputed constants. However, we will normalize the (hyper-)Laplacians as described in the following.","category":"page"},{"location":"dynamical_core/#Normalization-of-diffusion","page":"Dynamical core","title":"Normalization of diffusion","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In physics, the Laplace operator nabla^2 is often used to represent diffusion due to viscosity in a fluid. In that case, the viscosity coefficient is nu of units textm^2texts^-1 and the full operator reads as nu nabla^2 with units (textm^2texts^-1)(textm^-2) = texts^-1. This motivates us to normalize the Laplace operator by a constant of units textm^-2 and the viscosity coefficient by its inverse such that the viscosity coefficient becomes a damping timescale of unit texts^-1. Given the application in spectral space we decide to normalize by the largest eigenvalue l_textmax(l_textmax+1) such that all entries in the discrete spectral Laplace operator are in 01. The normalized viscosity coefficient nu^* = l_textmax(l_textmax+1)nu is therefore reinterpreted as the time scale at which the highest wavenumber is dampened to zero due to diffusion. Together we have ","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"D^textexplicit_lm = nu^* fracl(l+1)l_textmax(l_textmax+1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and the hyper-Laplacian of power n follows as","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"D^textexplicitn_lm = nu^* left(fracl(l+1)l_textmax(l_textmax+1)right)^n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and the implicit part is accordingly D^textimplicitn_lm = 1 + 2Delta t D^textexplicitn_lm.","category":"page"},{"location":"dynamical_core/#Radius-scaling","page":"Dynamical core","title":"Radius scaling","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"SpeedyWeather.jl uses a scaling for vorticity zeta and stream function Psi that is","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"tildezeta = zeta R tildePsi = Psi R^-1","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In the barotropic voriticity equation model the inversion of the Laplcians in order to obtain Psi from zeta therefore becomes","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"tildezeta = tildenabla^2 tildePsi","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"where the dimensionless gradients simply omit the scaling with 1R, tildenabla = Rnabla. The Barotropic vorticity equation scaled with R^2 is","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"partial_tildettildezeta + tildenabla cdot (mathbfu(tildezeta + tildef)) = tildenutildenabla^2ntildezeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"tildet = tR^-1, the scaled time t\nmathbfu = (uv), the velocity vector (no scaling applied)\ntildef = fR, the scaled Coriolis parameter f\ntildenu = nu^* R, the scaled viscosity nu^*, which itself is normalized to a damping time scale, see Normalization of diffusion.","category":"page"},{"location":"dynamical_core/#Scaled-shallow-water-equations","page":"Dynamical core","title":"Scaled shallow water equations","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Similar to the scaled barotropic vorticity equations, the scaled shallow water equations scale the vorticity and the divergence equation with R^2, but the continuity equation with R","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\nfracpartial tildezetapartial tildet + tildenabla cdot (mathbfu(tildezeta + tildef)) =\ntildenutildenabla^2ntildezeta \nfracpartial tildemathcalDpartial tildet - tildenabla times (mathbfu(tildezeta + tildef)) =\n-tildenabla^2left(tfrac12(u^2 + v^2) + geta right) + tildenutildenabla^2ntildemathcalD \nfracpartial etapartial tildet + tildenabla cdot (mathbfuh) = 0\nendaligned","category":"page"},{"location":"dynamical_core/#Time-integration","page":"Dynamical core","title":"Time integration","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"SpeedyWeather.jl uses a leapfrog time scheme with a Robert's and William's filter to dampen the computational mode and achieve 3rd order accuracy.","category":"page"},{"location":"dynamical_core/#Oscillation-equation","page":"Dynamical core","title":"Oscillation equation","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"fracdFdt = iomega F","category":"page"},{"location":"dynamical_core/#References","page":"Dynamical core","title":"References","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[1]: Geophysical Fluid Dynamics Laboratory, Idealized models with spectral dynamics","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[2]: Geophysical Fluid Dynamics Laboratory, The barotropic vorticity equation.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[3]: Geophysical Fluid Dynamics Laboratory, The Shallow Water Equations.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[4]: Geophysical Fluid Dynamics Laboratory, The Spectral Dynamical Core","category":"page"},{"location":"how_to_run_speedy/#How-to-run-SpeedyWeather.jl","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The simplest way to run SpeedyWeather.jl with default parameters is","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"using SpeedyWeather\nrun_speedy()","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Hooray, you have just simulated the Earth's atmosphere. Parameters, their meanings and defaults can be found in src/default_parameters.jl, an incomplete list is provided below. For example, if you want the simulation to run in double precision (Float64), at higher resolution (trunc, the triangular spectral truncation), slow down the rotation of the Earth (rotation_earth in s^-1) and create some netCDF ouput, do","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"run_speedy(Float64,trunc=85,rotation_earth=1e-5,output=true)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"If provided, the number format has to be the first argument, all other arguments are keyword arguments.","category":"page"},{"location":"how_to_run_speedy/#Incomplete-list-of-parameters","page":"How to run SpeedyWeather.jl","title":"Incomplete list of parameters","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The following list only contains some frequently used parameters. As SpeedyWeather.jl is developed this is by no means complete.","category":"page"},{"location":"how_to_run_speedy/#Resolution","page":"How to run SpeedyWeather.jl","title":"Resolution","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"parameter keyword default value meaning\nNF::DataType Float32 Number format (not keyword, first positional, but optional argument)\ntrunc::Int 31 Spectral triangular truncation , i.e. the maximum order and degree of the spherical harmonics\nnlev::Int 8 Number of vertical levels","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"### Physical parameters","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"parameter keyword default value meaning\nmodel::Symbol :barotropic Equations to be solved: :barotropic, :shallowwater, or :primitive\nradius_earth::Real 6.371e6 Radius of Earth [m]\nrotation_earth::Real 7.292e-5 Angular frequency of Earth's rotation [s^-1]\ngravity::Real 9.81 Gravitational acceleration [ms^2]","category":"page"},{"location":"how_to_run_speedy/#Diffusion","page":"How to run SpeedyWeather.jl","title":"Diffusion","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"parameter keyword default value meaning\ndiffusion_power::Real 4 Power n of Laplacian in horizontal diffusion nabla^2n\ndiffusion_time::Real 2.4 Diffusion time scale [hrs] for temperature and vorticity\ndiffusion_time_div::Real diffusion_time Diffusion time scale [hrs] for divergence\ndiffusion_time_strat::Real 12 Diffusion time scale [hrs] for extra nabla^2 in the stratosphere\ndamping_time_strat::Real 720 Damping time [hrs] for drag on zonal-mean wind in the stratosphere","category":"page"},{"location":"how_to_run_speedy/#Time-stepping","page":"How to run SpeedyWeather.jl","title":"Time stepping","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"parameter keyword default value meaning\nΔt_at_T85::Real 20 Time step in minutes for T85, scale linearly for specified trunc\nn_days::Real 10 Number of days to integrate for\nrobert_filter::Real 0.05 Robert (1966) time filter coefficeint to suppress computational mode\nwilliams_filter::Real 0.53 William's time filter (Amezcua 2011) coefficient for 3rd order acc","category":"page"},{"location":"how_to_run_speedy/#Spectral-transforms","page":"How to run SpeedyWeather.jl","title":"Spectral transforms","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"parameter keyword default value meaning\nrecompute_legendre::Bool false Recompute or precompute the Legendre polynomials in the transforms","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"### Output","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"parameter keyword default value meaning\nverbose::Bool true Print dialog for feedback\noutput::Bool false Store data in netCDF?\noutput_dt::Real 6 Output time step [hrs]\noutput_startdate::DateTime DateTime(2000,1,1) Start date of the time axis (default: Jan 1, 2000)\nout_path::String pwd() Path to output folder (default is current directory)","category":"page"},{"location":"how_to_run_speedy/#The-run_speedy-interface","page":"How to run SpeedyWeather.jl","title":"The run_speedy interface","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"run_speedy","category":"page"},{"location":"how_to_run_speedy/#SpeedyWeather.run_speedy","page":"How to run SpeedyWeather.jl","title":"SpeedyWeather.run_speedy","text":"progn_vars = run_speedy(NF,kwargs...)\n\nRuns SpeedyWeather.jl with number format NF and any additional parameters in the keyword arguments kwargs.... Any unspecified parameters will use the default values as defined in src/parameters.jl.\n\n\n\n\n\n","category":"function"},{"location":"how_to_run_speedy/#The-initialize_speedy-interface","page":"How to run SpeedyWeather.jl","title":"The initialize_speedy interface","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"initialize_speedy","category":"page"},{"location":"how_to_run_speedy/#SpeedyWeather.initialize_speedy","page":"How to run SpeedyWeather.jl","title":"SpeedyWeather.initialize_speedy","text":"progn_vars, diagn_vars, model_setup = initialize_speedy(NF,kwargs...)\n\nInitialize the model by returning\n\nprogn_vars, the initial conditions of the prognostic variables\ndiagn_vars, the preallocated the diagnotic variables (initialised to zero)\nmodel_setup, the collected pre-calculated structs that don't change throughout integration.\n\nThe keyword arguments kwargs are the same as for run_speedy. The model_setup contains fields that hold the parameters, constants, geometry, spectral transform, boundaries and diffusion.\n\n\n\n\n\n","category":"function"},{"location":"parametrizations/#Parameterizations","page":"Parameterizations","title":"Parameterizations","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"This page describes the mathematical formulation of the parameterizations used in SpeedyWeather.jl to represent physical processes in the atmopshere. Every section is followed by a brief description of implementation details.","category":"page"},{"location":"parametrizations/#Convection","page":"Parameterizations","title":"Convection","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Large-scale-condensation","page":"Parameterizations","title":"Large-scale condensation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Clouds","page":"Parameterizations","title":"Clouds","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Short-wave-radiation","page":"Parameterizations","title":"Short-wave radiation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Long-wave-radiation","page":"Parameterizations","title":"Long-wave radiation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Surface-fluxes-of-momentum-and-energy","page":"Parameterizations","title":"Surface fluxes of momentum and energy","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Vertical-diffusion","page":"Parameterizations","title":"Vertical diffusion","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"spectral_transform/#Spherical-Harmonic-Transform","page":"Spherical harmonic transform","title":"Spherical Harmonic Transform","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The following sections outline the implementation of the spherical harmonic transform (in short spectral transform) between the coefficients of the spherical harmonics (the spectral space) and the grid space on a longitude-latitude regular Gaussian grid.","category":"page"},{"location":"spectral_transform/#Inspiration","page":"Spherical harmonic transform","title":"Inspiration","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spectral transform implemented by SpeedyWeather.jl follows largely Justin Willmert's CMB.jl package and makes use of AssociatedLegendrePolynomials.jl and FFTW.jl (for Float32/64) or GenericFFT.jl (for generic) for the Fourier transform. Justin described his work in a Blog series [1][2][3][4][5][6][7][8].","category":"page"},{"location":"spectral_transform/#Spherical-harmonics","page":"Spherical harmonic transform","title":"Spherical harmonics","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spherical harmonics Y_lm of degree l and order m over the longitude phi = (02pi) and colatitudes theta = (-pi2pi2), are","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Y_lm(phi theta) = lambda_l^m(sintheta) e^imphi","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"with lambda_l^m being the pre-normalized associated Legendre polynomials, and e^imphi are the complex exponentials (the Fourier modes). Together they form a set of orthogonal basis functions on the sphere. For an interactive visualisation of the spherical harmonics, see here.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"info: Latitudes versus colatitudes\nThe implementations of the spherical transforms in SpeedyWeather.jl use colatitudes theta = (0pi) (0 at the north pole) but the dynamical core uses latitudes theta = (-pi2pi2) (pi2 at the north pole). However, all arrays are always sorted north to south such that [i,1] will access the northern-most grid points. Note: We may also use latitudes in the spherical harmonic transfom in the future for consistency. ","category":"page"},{"location":"spectral_transform/#Synthesis-(spectral-to-grid)","page":"Spherical harmonic transform","title":"Synthesis (spectral to grid)","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The synthesis (or inverse transform) takes the spectral coefficients a_lm and transforms them to grid-point values f(phitheta) (for the sake of simplicity first regarded as continuous). The synthesis is a linear combination of the spherical harmonics Y_lm with non-zero coefficients.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"f(phitheta) = sum_l=0^infty sum_m=-l^l a_lm Y_lm(phitheta)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"We obtain an approximation with a finite set of a_lm by truncating the series after l = l_max.","category":"page"},{"location":"spectral_transform/#Analysis-(grid-to-spectral)","page":"Spherical harmonic transform","title":"Analysis (grid to spectral)","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Starting in grid-point space we can transform a field f(lambdatheta) into the spectral space of the spherical harmonics by","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"a_lm = int_0^2pi int_-tfracpi2^tfracpi2 f(lambdatheta) Y_lm(lambdatheta) cos theta dtheta dlambda","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This integral has to be discretized to when grid-point values f(lambda_itheta_i) are used. For more details, see [7],[8].","category":"page"},{"location":"spectral_transform/#Spectral-packing","page":"Spherical harmonic transform","title":"Spectral packing","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Spectral packing is the way how the coefficients a_lm of the spherical harmonics of a given spectral field are stored in an array. SpeedyWeather.jl uses the conventional spectral packing of degree l and order m as illustrated in the following image (Cyp, CC BY-SA 3.0, via Wikimedia Commons)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/1/12/Rotating_spherical_harmonics.gif\">","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Every row represents an order l geq 0, starting from l=0 at the top. Every column represents an order m geq 0, starting from m=0 on the left. The coefficients of these spherical harmonics are directly mapped into a matrix a_lm as ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":" m   \nl a_00   \n a_10 a_11  \n a_20 a_12 a_22 \n a_30 a_13 a_23 a_33","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"which is consistently extended for higher degrees and orders. Consequently, all spectral fields are lower-triangular matrices with complex entries. The upper triangle excluding the diagonal explicitly stores zeros. Note that internally vector fields include an additional degree, such that l_max = m_max + 1 (see Gradients in spherical coordinates for more information). The harmonics with a_l0 (the first column) are also called zonal harmonics as they are constant with longitude phi. The harmonics with a_ll (the main diagonal) are also called sectoral harmonics as they essentially split the sphere into 2l sectors in longitude phi without a zero-crossing in latitude.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"info: Array indices\nFor a spectral field alms note that due to Julia's 1-based indexing the coefficient a_lm is obtained via alms[l+1,m+1].","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Fortran speedy does not use the same spectral packing as SpeedyWeather.jl. The alternative packing lm therein uses l=m and m=l-m as summarized in the following table.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"degree l order m l=m m=l-m\n0 0 0 0\n1 0 0 1\n1 1 1 0\n2 0 0 2\n2 1 1 1\n2 2 2 0\n3 0 0 3\n... ... ... ...","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This alternative packing uses the top-left triangle of a coefficient matrix, and the degrees and orders from above are stored at the following indices","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":" m   \nl a_00 a_10 a_20 a_30\n a_11 a_21 a_31 \n a_22 a_32  \n a_33   ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This spectral packing is not used in SpeedyWeather.jl but illustrated here for completeness and comparison with Fortran-speedy.","category":"page"},{"location":"spectral_transform/#Example-transforms","page":"Spherical harmonic transform","title":"Example transforms","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"julia> using SpeedyWeather\njulia> alms = zeros(ComplexF64,3,3)    # spectral coefficients\njulia> alms[2,2] = 1                   # only l=1,m=1 harmonic\njulia> map = gridded(alms)             # convert to grid space\n8×4 Matrix{Float64}:\n -0.324541  -0.600363  -0.600363  -0.324541\n -0.134429  -0.248678  -0.248678  -0.134429\n  0.134429   0.248678   0.248678   0.134429\n  0.324541   0.600363   0.600363   0.324541\n  0.324541   0.600363   0.600363   0.324541\n  0.134429   0.248678   0.248678   0.134429\n -0.134429  -0.248678  -0.248678  -0.134429\n -0.324541  -0.600363  -0.600363  -0.324541\n \njulia> spectral(map)                   # back to spectral space\n3×3 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im          0.0+0.0im\n 0.0+0.0im  1.0+3.60727e-17im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im          0.0+0.0im","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"and we have successfully reobtained the l=m=1 spherical harmonic.","category":"page"},{"location":"spectral_transform/#Available-horizontal-resolutions","page":"Spherical harmonic transform","title":"Available horizontal resolutions","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"SpeedyWeather.jl uses triangular truncation such that only spherical harmonics with l leq l_max and m leq m_max are explicitly represented. This is usually described as Tm_max, with l_max = m_max (although in vector quantities require one more degree l in the recursion relation of meridional gradients). For example, T31 is the spectral resolution with l_max = m_max = 31. Note that the degree l and order m are mathematically 0-based, such that the corresponding coefficient matrix is of size 32x32.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Using triangular truncation[9], there are constraints on the corresponding grid resolution. Let nlon, nlat be the number of longitudes, latitudes on a regular Gaussian grid. Then spectral and grid resolution have to be chosen such that","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nlon geq 3l_max+1\nnlat geq (3l_max+1)2","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"In general, we choose nlon = 2nlat, and ideally nlon is easily Fourier-transformable, e.g. nlon = 2^i3^j5^k with some integers ijk geq 0. SpeedyWeather.jl is tested at the following horizontal resolutions, with Delta x = tfrac2pi Rnlon as the approximate grid spacing at the Equator","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"l_max nlon nlat Delta x\n31 (default) 96 48 400 km\n42 128 64 300 km\n85 256 128 160 km\n170 512 256 80 km\n341 1024 512 40 km\n682 2048 1024 20 km","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Choosing trunc as argument in run_speedy will automatically choose nlon,nlat as presented in the table. Other common choices are T63 (192x96), T127 (384x192), T255 (768x384), T511 (1536x768), among others.","category":"page"},{"location":"spectral_transform/#Derivatives-in-spherical-coordinates","page":"Spherical harmonic transform","title":"Derivatives in spherical coordinates","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Horizontal gradients in spherical coordinates are defined for a scalar field A and the latitudes theta and longitudes lambda as","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nabla A = left(frac1Rcosthetafracpartial Apartial lambda frac1Rfracpartial Apartial theta right)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"However, the divergence of a vector field mathbfu = (uv) includes additional cos(theta) scalings","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nabla cdot mathbfu = frac1Rcosthetafracpartial upartial lambda +\nfrac1Rcosthetafracpartial (v costheta)partial theta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"and similar for the curl","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nabla times mathbfu = frac1Rcosthetafracpartial vpartial lambda -\nfrac1Rcosthetafracpartial (u costheta)partial theta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The radius of the sphere (i.e. Earth) is R. The zonal gradient scales with 1cos(theta) as the  longitudes converge towards the poles (note that theta describes latitudes here, defintions using colatitudes replace the cos with a sin.)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Starting with a spectral field of vorticity zeta and divergence mathcalD one can obtain stream function Psi and velocity potential Phi by inverting the Laplace operator nabla^2:","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Psi = nabla^-2zeta quad Phi = nabla^-2mathcalD","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The velocities uv are then obtained from (uv) = nabla^botPsi + nablaPhi following the defintion from above and nabla^bot = (-R^-1partial_theta (Rcostheta)^-1partial_lambda)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nu = -frac1Rpartial_thetaPsi + frac1Rcosthetapartial_lambdaPhi \nv = +frac1Rpartial_thetaPhi + frac1Rcosthetapartial_lambdaPsi\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Alternatively, we can use the velocities U = ucostheta V = vcostheta, which we do as the meridional gradient for spherical harmonics is easier implemented with a costheta-scaling included, and because the divergence and  curl in spherical coordinates evaluates the meridional gradient with UV and not uv. From uv we can return to zeta mathcalD via","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nzeta = frac1Rcosthetapartial_lambda v - frac1Rcosthetapartial_theta (u costheta) \nmathcalD = frac1Rcosthetapartial_lambda u + frac1Rcosthetapartial_theta (v costheta)\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Equivalently, we have","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nU = -fraccosthetaRpartial_thetaPsi + frac1Rpartial_lambdaPhi \nV = +fraccosthetaRpartial_thetaPhi + frac1Rpartial_lambdaPsi \nzeta = frac1Rpartial_lambda left( fracVcos^2theta right) -\nfraccosthetaRpartial_theta left( fracUcos^2theta right) \nmathcalD = frac1Rpartial_lambda left( fracUcos^2theta right) +\nfraccosthetaRpartial_theta left( fracVcos^2theta right)\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"which is a more convenient formulation as required costheta scalings are reduced to a minimum. The remaining (UV)*cos^-2theta are done in grid-point space and usually in combination with other operations like the computation of the vorticity flux. But also note that SpeedyWeather.jl scales the equations with the radius R (see Radius scaling) such that the divisions by R drop out too. As described in Meridional derivative, it is more convenient to implement costheta partial_theta via a recursion relation for the Legendre polynomials than partial_theta directly. How the operators nabla nabla times nabla cdot can be implemented with spherical harmonics is presented in the following sections.","category":"page"},{"location":"spectral_transform/#Zonal-derivative","page":"Spherical harmonic transform","title":"Zonal derivative","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The zonal derivative of a scalar field Psi in spectral space is the zonal derivative of all its respective spherical harmonics Psi_lm(phitheta) (now we use phi for longitudes to avoid confusion with the Legendre polynomials lambda_lm)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"v_lm = frac1R cos(theta) fracpartialpartial phi left( lambda_l^m(costheta) e^imphi right) =\nfracimR cos(theta) lambda_l^m(costheta) e^imphi = fracimR cos(theta) Psi_lm","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"So for every spectral harmonic, cos(theta)v_lm is obtained from Psi_lm via a multiplication with imR. Unscaling the cos(theta)-factor is done after transforming the spectral coefficients v_lm into grid-point space. As discussed in Radius scaling, SpeedyWeather.jl scales the stream function as tildePsi = R^-1Psi such that the division by radius R in the gradients can be omitted. The zonal derivative becomes therefore effectively for each spherical harmonic a scaling with its (imaginary) order im. The spherical harmonics are essentially just a Fourier transform in zonal direction and the derivative a multiplication with the respective wave number m times imaginary i.","category":"page"},{"location":"spectral_transform/#Meridional-derivative","page":"Spherical harmonic transform","title":"Meridional derivative","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The meridioinal derivative of the spherical harmonics is a derivative of the Legendre polynomials for which the following recursion relation applies[10],[11]","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"costheta fracdP_lmdtheta = -lepsilon_l+1mP_l+1m + (l+1)epsilon_lmP_l-1m","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"with recursion factors","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"epsilon_lm = sqrtfracl^2-m^24l^2-1","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"In the following we use the example of obtaining the zonal velocity u from the stream function Psi, which is through the negative meridional gradient. For the meridional derivative itself the leading minus sign has to be omitted. Starting with the spectral expansion","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Psi(lambdatheta) = sum_lmPsi_lmP_lm(sintheta)e^imlambda","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"we multiply with -R^-1costhetapartial_theta to obtain","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"costhetaleft(-frac1Rpartial_thetaPsi right) = -frac1Rsum_lmPsi_lme^imlambdacosthetapartial_theta P_lm","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"at which point the recursion from above can be applied. Collecting terms proportional to P_lm then yields","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"(cos(theta)u)_lm = -frac1R(-(l-1)epsilon_lmPsi_l-1m + (l+2)epsilon_l+1mPsi_l+1m)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"To obtain the coefficient of each spherical harmonic lm of the meridional gradient of a spectral field, two  coefficients at l-1m and l+1m have to be combined. This means that the coefficient of a gradient ((costheta) u)_lm is a linear combination of the coefficients of one higher and one lower degree Psi_l+1mPsi_l-1m. As the coefficient Psi_lm with ml are zero, the sectoral harmonics (l=m) of the gradients are obtained from the first off-diagonal only. However, the l=l_max harmonics of the gradients require the l_max-1 as well as the l_max+1 harmonics. In SpeedyWeather.jl vector quantitie like uv use therefore one more meridional mode than scalar quantities such as vorticity zeta or stream function Psi. The meridional derivative in SpeedyWeather.jl also omits the 1R-scaling as explained for the Zonal derivative and in Radius scaling.","category":"page"},{"location":"spectral_transform/#Divergence-and-curl-in-spherical-harmonics","page":"Spherical harmonic transform","title":"Divergence and curl in spherical harmonics","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The meridional gradient as described above can be applied to scalars, such as Psi and Phi in the conversion to velocities (uv) = nabla^botPsi + nablaPhi, however, the operators curl nabla times and divergence nabla cdot in spherical coordinates involve a costheta scaling before the meridional gradient is applied. How to translate this to spectral coefficients has to be derived separately[10],[11].","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spectral transform of vorticity zeta is","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"zeta_lm = frac12piint_-tfracpi2^tfracpi2int_0^2pi zeta(lambdatheta) P_lm(sintheta) e^imlambda dlambda costheta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Given that Rzeta = cos^-1partial_lambda v - cos^-1partial_theta (u costheta), we therefore have to evaluate a meridional integral of the form","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"int P_lm frac1cos theta partial_theta(u costheta)) cos theta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"which can be solved through integration by parts. As ucostheta = 0 at theta = pm tfracpi2 only the integral","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"= -int partial_theta P_lm (u costheta) dtheta = -int costheta partial_theta P_lm (fracucostheta) costheta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"remains. Inserting the recurrence relation from the Meridional derivative turns this into","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"= -int left(-l epsilon_l+1mP_l+1m + (l+1)epsilon_lm P_l-1m right) (fracucostheta) cos theta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Now we expand (tfracucostheta) but only the lm harmonic will project ontoP_lm. Let u^* = ucos^-1theta v^* = vcos^-1theta we then have in total","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nRzeta_lm = imv^*_lm + (l+1)epsilon_lmu^*_l-1m - lepsilon_l+1mu^*_l+1m \nRD_lm = imu^*_lm - (l+1)epsilon_lmv^*_l-1m + lepsilon_l+1mv^*_l+1m \nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"And the divergence D is similar, but (uv) to (-vu). We have moved the scaling with the radius R directly into zetaD as further described in Radius scaling.","category":"page"},{"location":"spectral_transform/#Laplacian","page":"Spherical harmonic transform","title":"Laplacian","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spectral Laplacian is easily applied to the coefficients Psi_lm of a spectral field as the spherical harmonics are eigenfunctions of the Laplace operator nabla^2 in spherical coordinates with eigenvalues -l(l+1) divided by the radius squared R^2, i.e. nabla^2 Psi becomes tfrac-l(l+1)R^2Psi_lm in spectral space. For example, vorticity zeta and streamfunction Psi are related by zeta = nabla^2Psi in the barotropic vorticity model. Hence, in spectral space this is equivalent for every spectral mode of degree l and order m to","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"zeta_lm = frac-l(l+1)R^2Psi_lm","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This can be easily inverted to obtain the stream function Psi from vorticity zeta instead. In order to avoid division by zero, we set Psi_00 here, given that the stream function is only defined up to a constant anyway.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nPsi_lm = fracR^2-l(l+1)zeta_lm quad foralllm  0\nPsi_00 = 0\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"See also Horizontal diffusion and Normalization of diffusion.","category":"page"},{"location":"spectral_transform/#U,V-from-vorticity-and-divergence","page":"Spherical harmonic transform","title":"U,V from vorticity and divergence","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"After having discussed the zonal and meridional derivatives with spherical harmonics as well as the Laplace operator, we can derive the conversion from vorticity zeta and divergence D (which are prognostic variables) to U=ucostheta V=vcostheta. Both are linear operations that act either solely on a given harmonic (the zonal gradient and the Laplace operator) or are linear combinations between one lower and one higher degree l (the meridional gradient). It is therefore computationally more efficient to compute UV directly from zetaD instead of calculating stream function and velocity potential first. In total we have","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nU_lm = -fraciml(l+1)(RD)_lm + fracepsilon_l+1ml+1(Rzeta)_l+1m - fracepsilon_lml(Rzeta)_l-1m \nV_lm = -fraciml(l+1)(Rzeta)_lm - fracepsilon_l+1ml+1(RD)_l+1m + fracepsilon_lml(RD)_l-1m \nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"We have moved the scaling with the radius R directly into zetaD as further described in Radius scaling.","category":"page"},{"location":"spectral_transform/#References","page":"Spherical harmonic transform","title":"References","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[1]: Justin Willmert, 2020. Introduction to Associated Legendre Polynomials (Legendre.jl Series, Part I)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[2]: Justin Willmert, 2020. Calculating Legendre Polynomials (Legendre.jl Series, Part II)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[3]: Justin Willmert, 2020. Pre-normalizing Legendre Polynomials (Legendre.jl Series, Part III)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[4]: Justin Willmert, 2020. Maintaining numerical accuracy in the Legendre recurrences (Legendre.jl Series, Part IV)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[5]: Justin Willmert, 2020. Introducing Legendre.jl (Legendre.jl Series, Part V)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[6]: Justin Willmert, 2020. Numerical Accuracy of the Spherical Harmonic Recurrence Coefficient (Legendre.jl Series Addendum)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[7]: Justin Willmert, 2020. Notes on Calculating the Spherical Harmonics","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[8]: Justin Willmert, 2022. More Notes on Calculating the Spherical Harmonics: Analysis of maps to harmonic coefficients","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[9]: David Randall, 2021. An Introduction to Numerical Modeling of the Atmosphere, Chapter 22.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[10]: Dale Durran, 2010. Numerical Methods for Fluid Dynamics, Springer. In particular section 6.2, 6.4.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[11]: Geophysical Fluid Dynamics Laboratory, The barotropic vorticity equation.","category":"page"},{"location":"new_model_setups/#New-model-setups","page":"New model setups","title":"New model setups","text":"","category":"section"},{"location":"new_model_setups/","page":"New model setups","title":"New model setups","text":"more to come...","category":"page"},{"location":"#SpeedyWeather.jl-documentation","page":"Home","title":"SpeedyWeather.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SpeedyWeather.jl a global atmospheric circulation model with simple parametrizations to represent physical processes such as clouds, precipitation and radiation.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is a global spectral model that uses a Fourier and Legendre transform to calculcate tendencies of the prognostic variables vorticity, divergence, absolute temperature, logarithm of surface pressure and specific humidity. The time stepping uses a leapfrog scheme with additional filters and a semi-implicit formulation for gravity waves. The default resolution is T31 (96x48 grid points on a Gaussian grid, about 400km at the Equator) and 8 vertical levels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple parameterizations are used to represent the physical processes convection, large-scale condensation, clouds, short-wave radiation, long-waves radiation, surface fluxes of momentum and energy, and vertical diffusion.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the following pages of the documentation for more details","category":"page"},{"location":"","page":"Home","title":"Home","text":"How to run SpeedyWeather.jl\nSpherical harmonic transform\nDynamical core\nParametrizations\nNew model setups\nFunction and type index","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the original documentation by Molteni and Kucharski.","category":"page"},{"location":"#Scope","page":"Home","title":"Scope","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The focus of SpeedyWeather.jl is to develop a global atmospheric model of intermediate complexity, that can run at various levels of precision (16, 32 and 64-bit) on different architectures (x86 and ARM, currently planned, GPUs probably in the future). Additionally, the model is written in an entirely number format-flexible way, such that any custom number format can be used and Julia will compile to the format automatically.","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is a Julia implementation of SPEEDY, which is written in Fortran 77. Sam Hatfield translated SPEEDY to Fortran 90 and started the project to port it to Julia. However, we are making an effort to overhaul the implementation of the mathematical model behind speedy completely and it is unlikely that a single line of code survived.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is registered in the Julia Registry. Open Julia's package manager from the REPL with ] and add the github repository to install SpeedyWeather.jl and all dependencies","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.7) pkg> add SpeedyWeather","category":"page"},{"location":"","page":"Home","title":"Home","text":"which will automatically install the latest release. However, you may want to install directly from the main branch with","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.7) pkg> add https://github.com/milankl/SpeedyWeather.jl#main","category":"page"},{"location":"","page":"Home","title":"Home","text":"other branches than #main can be installed by adding #branch_name instead.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is currently developed by","category":"page"},{"location":"","page":"Home","title":"Home","text":"Milan Klöwer\nTom Kimpson\nAlistair White","category":"page"},{"location":"","page":"Home","title":"Home","text":"Any contributions are always welcome!","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is funded by the European Research Council under Horizon 2020 within the ITHACA project, grant agreement number 741112.","category":"page"},{"location":"boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This page describes the formulation of boundary conditions and their implementation.","category":"page"},{"location":"time_integration/#Time-integration","page":"Time integration","title":"Time integration","text":"","category":"section"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"SpeedyWeather.jl uses a leapfrog time scheme with a Robert's and William's filter to dampen the computational mode and achieve 3rd order accuracy.","category":"page"},{"location":"time_integration/#Oscillation-equation","page":"Time integration","title":"Oscillation equation","text":"","category":"section"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"fracdFdt = iomega F","category":"page"},{"location":"time_integration/#Implementation-details","page":"Time integration","title":"Implementation details","text":"","category":"section"}]
}
