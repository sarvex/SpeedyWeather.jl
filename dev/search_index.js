var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-and-type-index","page":"Function and type index","title":"Function and type index","text":"","category":"section"},{"location":"functions/#Parameters-and-constants","page":"Function and type index","title":"Parameters and constants","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Parameters\nSpeedyWeather.Constants","category":"page"},{"location":"functions/#SpeedyWeather.Parameters","page":"Function and type index","title":"SpeedyWeather.Parameters","text":"Parameter struct that holds all parameters that define the default model setup. With keywords such that default values can be changed at creation.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.Constants","page":"Function and type index","title":"SpeedyWeather.Constants","text":"Struct holding the parameters needed at runtime in number format NF.\n\n\n\n\n\n","category":"type"},{"location":"functions/#Boundaries-and-boundary-conditions","page":"Function and type index","title":"Boundaries and boundary conditions","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Boundaries","category":"page"},{"location":"functions/#SpeedyWeather.Boundaries","page":"Function and type index","title":"SpeedyWeather.Boundaries","text":"Struct that holds the boundary arrays in grid-point space     geopotsurf     ::Array{Complex{NF},2}  # spectral surface geopotential (orography * gravity) [m^2/s^2]     landseamask    ::Array{NF,2}           # land-sea mask, grid-point     albedo          ::Array{NF,2}           # annual mean surface albedo, grid-point\n\n\n\n\n\n","category":"type"},{"location":"functions/#Spherical-harmonic-transform","page":"Function and type index","title":"Spherical harmonic transform","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.GeoSpectral\nSpeedyWeather.SpectralTransform\nSpeedyWeather.spectral\nSpeedyWeather.spectral!\nSpeedyWeather.gridded\nSpeedyWeather.gridded!\nSpeedyWeather.triangular_truncation\nSpeedyWeather.roundup_fft\nSpeedyWeather.spectral_truncation\nSpeedyWeather.spectral_truncation!\nSpeedyWeather.get_legendre_polynomials!\nSpeedyWeather.∇²!\nSpeedyWeather.∇²\nSpeedyWeather.∇⁴!\nSpeedyWeather.∇⁴\nSpeedyWeather.∇⁻²!\nSpeedyWeather.∇⁻²\nSpeedyWeather.gradient_latitude!\nSpeedyWeather.gradient_latitude\nSpeedyWeather.gradient_longitude!\nSpeedyWeather.gradient_longitude\nSpeedyWeather.divergence_uvω_spectral\nSpeedyWeather.ϵlm     ","category":"page"},{"location":"functions/#SpeedyWeather.GeoSpectral","page":"Function and type index","title":"SpeedyWeather.GeoSpectral","text":"G = Geospectral{NF}(geometry,spectral_transform)\n\nStruct that holds both a Geometry struct geometry and a SpectralTransform struct spectral_transform.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.SpectralTransform","page":"Function and type index","title":"SpeedyWeather.SpectralTransform","text":"SpectralTransform struct that contains all parameters and preallocated arrays for the spectral transform.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.spectral","page":"Function and type index","title":"SpeedyWeather.spectral","text":"alms = spectral(map)\n\nForward spectral transform (grid to spectral space) from the gridded field map on a regular Gaussian grid (with Gaussian latitudes) into the spectral coefficients of the Legendre polynomials alms. Based on the size of map this function retrieves the corresponding spectral resolution via triangular truncation and sets up a SpectralTransform struct S to execute spectral(map,S).\n\n\n\n\n\nalms = spectral(map,S)\n\nForward spectral transform (grid to spectral space) from the gridded field map on a regular Gaussian grid (with Gaussian latitudes) and the SpectralTransform struct S into the spectral coefficients of the Legendre polynomials alms. This function allocates alms and executes spectral!(alms,map,S).\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.spectral!","page":"Function and type index","title":"SpeedyWeather.spectral!","text":"spectral!(alms,map,S)\n\nForward spectral transform (grid to spectral space) from the gridded field map on a regular Gaussian grid (with Gaussian latitudes). Uses a planned real-valued Fast Fourier Transform in the zonal direction, and a Legendre Transform in the meridional direction exploiting symmetries.Either recomputes the Legendre polynomials Λ for each latitude on one hemisphere or uses precomputed polynomials from S.Λs, depending on S.recompute_legendre. Further uses Legendre weights on Gaussian latitudes for a leakage-free transform.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.gridded","page":"Function and type index","title":"SpeedyWeather.gridded","text":"map = gridded(alms)\n\nBackward or inverse spectral transform (spectral to grid space) from coefficients alms. Based on the size of alms the corresponding grid space resolution is retrieved based on triangular truncation and a  SpectralTransform struct S is allocated to execute gridded(alms,S).\n\n\n\n\n\nmap = gridded(alms,S)\n\nBackward or inverse spectral transform (spectral to grid space) from coefficients alms and the  SpectralTransform struct S. Allocates the output map with Gaussian latitudes and executes gridded!(map,alms,S).\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.gridded!","page":"Function and type index","title":"SpeedyWeather.gridded!","text":"gridded!(map,alms,S)\n\nBackward or inverse spectral transform (spectral to grid space) from coefficients alms and SpectralTransform struct S into the preallocated output map. Uses a planned inverse Fast Fourier Transform for efficiency in the zonal direction and a Legendre Transform in the meridional direction exploiting symmetries for effciency. Either recomputes the Legendre polynomials to save memory, or uses precomputed polynomials from S depending on S.recompute_legendre.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.triangular_truncation","page":"Function and type index","title":"SpeedyWeather.triangular_truncation","text":"triangular_truncation(trunc::Int,nlon::Int,nlat::Int)\n\nTests whether the inputs trunc, nlon, nlat satisfy the triangular truncation constraints. trunc is the maximum degree and order of the Legendre polynomials (0-based), nlon is the number of longitudes, nlat the number of latitudes on the spatial grid. The constraints are\n\n- nlon >= 3T+1\n- nlat >= (3T+1)/2\n- nlon = 2nlat.\n\n\n\n\n\nnlon, nlat = triangular_truncation(trunc::Int)\n\nReturns the grid size nlon,nlat for a spectral truncation trunc that satisfies the triangular truncation constraints. Returns the smallest pair nlon,nlat that is also easily Fast Fourier-transformable, as determined in roundup_fft.\n\n\n\n\n\ntrunc = triangular_truncation(nlon::Int,nlat::Int)\n\nReturns the largest spectral truncation trunc that satisfies the triangular truncation constraints based on the grid size nlon,nlat, which may or may not be easily Fast Fourier-transformable.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.roundup_fft","page":"Function and type index","title":"SpeedyWeather.roundup_fft","text":"m = roundup_fft(n::Int)\n\nReturns an integer m >= n with only prime factors 2 and 3 to obtain an efficiently fourier-transformable number of longitudes, m = 2^i * 3^j >= n, with i>=0 but j = 0,1.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.spectral_truncation","page":"Function and type index","title":"SpeedyWeather.spectral_truncation","text":"alms_trunc = spectral_truncation(alms,trunc)\n\nReturns a spectral coefficient matrix alms_trunc that is truncated from alms to the size (trunc+1)^2. alms_trunc only contains those coefficient of alms for which m,l <= trunc, and m>l are zero anyway. If trunc is larger than the implicit truncation in alms obtained from its size than spectral_interpolation is automatically called instead, returning alms_interp, a coefficient matrix that is larger than alms with padded zero coefficients.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.spectral_truncation!","page":"Function and type index","title":"SpeedyWeather.spectral_truncation!","text":"spectral_truncation!(alms,ltrunc,mtrunc)\n\nTruncate spectral coefficients alms in-place by setting (a) the upper right triangle to zero and (b) all coefficients for which the degree l is larger than the truncation ltrunc or order m larger than the truncaction mtrunc.\n\n\n\n\n\nspectral_truncation!(alms,trunc)\n\nTruncate spectral coefficients alms in-place by setting (a) the upper right triangle to zero and (b) all coefficients for which the degree l is larger than the truncation trunc.\n\n\n\n\n\nspectral_truncation!(alms)\n\nTruncate spectral coefficients alms in-place by setting the upper right triangle to zero. This is to enforce that all coefficients for which the degree l is larger than order m are zero.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.get_legendre_polynomials!","page":"Function and type index","title":"SpeedyWeather.get_legendre_polynomials!","text":"get_legendre_polynomials!(Λ,Λs,ilat,cos_colat,recompute_legendre)\n\nBase on recompute_legendre (true/false) this function either updates the Legendre polynomials Λ for a given latitude ilat, cos_colat by recomputation (recompute_legendre == true), or Λ is changed by copying over the polynomials from precomputed Λs. Recomputation takes usually longer, but precomputation requires a large amount of memory for high resolution.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.∇⁻²!","page":"Function and type index","title":"SpeedyWeather.∇⁻²!","text":"∇⁻²!(   ∇⁻²alms::AbstractMatrix{Complex},\n        alms::AbstractMatrix{Complex},\n        R::Real=1)\n\nInverse spherical Laplace operator ∇⁻² applied to the spectral coefficients alms on a sphere of radius R. ∇⁻²! is the in-place version which directly stores the output in the argument ∇⁻²alms. The integration constant for Legendre polynomial l=m=0 is zero. The inverse spherical Laplace operator is\n\n∇⁻²alms = alms*R²/(-l(l+1))\n\nwith the degree l (0-based) of the Legendre polynomial.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.gradient_latitude!","page":"Function and type index","title":"SpeedyWeather.gradient_latitude!","text":"gradient_latitude!( coslat_u::AbstractArray{Complex{NF}},   # output: cos(lat)*zonal velocity u\n                    Ψ::AbstractArray{Complex{NF}},          # input: streamfunction Ψ\n                    ϵlms::AbstractArray{NF},                # recursion factors\n                    R::Real=1                               # radius of the sphere/Earth\n                    ) where {NF<:AbstractFloat}             # number format NF\n\nMeridional gradient in spectral space of spherical harmonic coefficients Ψ on a sphere with radius R. Returns coslat_u, i.e. the gradient ∂Ψ/∂lat with an additional cosine of latitude scaling. This function uses the recursion relation (0-based degree l, order m)\n\n(coslat u)_lm = -1/R*(-(l-1)*ϵ_lm*Ψ_l-1,m + (l+2)*ϵ_l+1,m*Ψ_l+1,m ).\n\nAs u = -1/R*∂Ψ/∂lat, this function can be generally used to compute the gradient in latitude.\n\n\n\n\n\ngradient_latitude! but precalculate the recursion factors ϵlms in case they are not provided.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.gradient_longitude!","page":"Function and type index","title":"SpeedyWeather.gradient_longitude!","text":"coslat_v = gradient_longitude!( coslat_v::AbstractMatrix{Complex{NF}},\n                                Ψ::AbstractMatrix{Complex{NF}};\n                                R::Real=1\n                                ) where {NF<:AbstractFloat}\n\nZonal gradient in spectral space of spherical harmonic coefficients Ψ on a sphere with radius R. While the zonal gradient is 1/coslat∂/∂lon in spherical coordinates, this functions omits the 1/coslat scaling such that the return array is coslat∂alms/∂lon.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.gradient_longitude","page":"Function and type index","title":"SpeedyWeather.gradient_longitude","text":"Gradient in longitude in spectral space. Input: coefficients alms of the spherical harmonics.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.divergence_uvω_spectral","page":"Function and type index","title":"SpeedyWeather.divergence_uvω_spectral","text":"Spectral tendency of ∇⋅(uv*ω) from vector uv=(u,v) in grid space and absolute vorticity ω. Step 1 (grid space): Add Coriolis f to the relative vorticity ζ (=vor_grid) to obtain abs vorticity ω. Step 2 (grid space): Multiply u,v with abs vorticity ω. Step 3 (grid space): Unscale with coslat, cosine of latitude, as the gradients will include a coslat term. Step 4 (spectral space): convert uω/coslat, vω/coslat from grid to spectral space Step 5 (spectral space): Compute gradients ∂/∂lon(uω/coslat) and ∂/∂lat(vω/coslat) Step 6 (spectral space): Add ∂/∂lon(uω/coslat)+∂/∂θ(vω/coslat) and return.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.ϵlm","page":"Function and type index","title":"SpeedyWeather.ϵlm","text":"ϵ = ϵ(NF,l,m)\n\nRecursion factors ϵ as a function of degree l and order m (0-based) of the spherical harmonics. ϵ(l,m) = sqrt((l^2-m^2)/(4*l^2-1)) and then converted to number format NF.\n\n\n\n\n\nϵ = ϵ(l,m)\n\nRecursion factors ϵ as a function of degree l and order m (0-based) of the spherical harmonics. ϵ(l,m) = sqrt((l^2-m^2)/(4*l^2-1)) with default number format Float64.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Geometry","page":"Function and type index","title":"Geometry","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Geometry\nSpeedyWeather.vertical_coordinates\nSpeedyWeather.GenLogisticCoefs\nSpeedyWeather.generalised_logistic","category":"page"},{"location":"functions/#SpeedyWeather.Geometry","page":"Function and type index","title":"SpeedyWeather.Geometry","text":"Geometry struct containing parameters and arrays describing the Gaussian grid and the vertical levels. NF is the number format used for the precomputed constants.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.vertical_coordinates","page":"Function and type index","title":"SpeedyWeather.vertical_coordinates","text":"Vertical sigma coordinates defined by their nlev+1 half levels σ_levels_half. Sigma coordinates are fraction of surface pressure (p/p0) and are sorted from top (stratosphere) to bottom (surface). The first half level is at 0 the last at 1. Evaluate a generalised logistic function with coefficients in P for the distribution of values in between. Default coefficients follow the L31 configuration historically used at ECMWF.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.GenLogisticCoefs","page":"Function and type index","title":"SpeedyWeather.GenLogisticCoefs","text":"Coefficients of the generalised logistic function to describe the vertical coordinate. Default coefficients A,K,C,Q,B,M,ν are fitted to the old L31 configuration at ECMWF. See geometry.jl and function vertical_coordinate for more informaiton.\n\nFollowing the notation of https://en.wikipedia.org/wiki/Generalisedlogisticfunction (Dec 15 2021).\n\nChange default parameters for more/fewer levels in the stratosphere vs troposphere vs boundary layer.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.generalised_logistic","page":"Function and type index","title":"SpeedyWeather.generalised_logistic","text":"Generalised logistic function based on the coefficients in coefs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Time-stepping","page":"Function and type index","title":"Time stepping","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.time_stepping!\nSpeedyWeather.time_step!\nSpeedyWeather.first_timestep!\nSpeedyWeather.leapfrog!","category":"page"},{"location":"functions/#SpeedyWeather.time_stepping!","page":"Function and type index","title":"SpeedyWeather.time_stepping!","text":"Main time loop.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.leapfrog!","page":"Function and type index","title":"SpeedyWeather.leapfrog!","text":"Leapfrog! for 3D arrays that loops over all vertical layers.\n\n\n\n\n\nleapfrog!(  A::AbstractArray{Complex{NF},3},        # a prognostic variable (spectral)\n            tendency::AbstractMatrix{Complex{NF}},  # tendency (dynamics+physics) of A\n            dt::NF,                                 # time step (=2Δt, but for init steps =Δt,Δt/2)\n            C::Constants{NF},                       # struct with constants used at runtime\n            lf::Int=2                               # leapfrog index to dis/enable(default) William's filter\n            ) where {NF<:AbstractFloat}             # number format NF\n\nPerforms one leapfrog time step with or without Robert+William's filter (see William (2009), Montly Weather Review, Eq. 7-9).\n\n\n\n\n\nA leapfrog! function that loops over all prognostic variables.\n\n\n\n\n\n","category":"function"},{"location":"conventions/#Style-and-convention-guide","page":"Style and convention guide","title":"Style and convention guide","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"In SpeedyWeather.jl we've been following the several conventions that are documented here.","category":"page"},{"location":"conventions/#Variable-naming","page":"Style and convention guide","title":"Variable naming","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"The prognostic variables in spectral space are called","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    vor         # Vorticity of horizontal wind field\n    div         # Divergence of horizontal wind field\n    temp        # Absolute temperature [K]\n    pres_surf   # Logarithm of surface pressure [log(Pa)]\n    humid       # Specific humidity [g/kg]","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"their transforms into grid-point space get a _grid suffix, their tendencies a _tend suffix. Further derived diagnostic dynamic variables are","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    u\n    v\n    geopot\n    ...","category":"page"},{"location":"conventions/#Preallocation","page":"Style and convention guide","title":"Preallocation","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"All arrays representing variables are preallocated and grouped into two structs","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    Prog::PrognosticVariables\n    Diag::DiagnosticVariables","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"The Diag struct contains further structs which represent the grid-point transformations of the prognostic variables and their tendencies.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    gridvars::GridVariables\n    tendencies::Tendencies\n    ...","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Constant arrays are grouped into several structs","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Boundaries","category":"page"},{"location":"conventions/#Julian-conventions","page":"Style and convention guide","title":"Julian conventions","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"We follow Julia's style guide and highlight here some important aspects of it.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Bang (!) convention. A function func does not change its input arguments, however, func! does.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Hence, func! is often the in-place version of func, avoiding as much memory allocation as possible and often changing its first argument, e.g. func!(out,in) so that argument in is used to calculate out which has been preallocated before function call.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Number format flexibility. Numeric literals such as 2.0 or 1/3 are only used in the model setup","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"but avoided throughout the code to obtain a fully number format-flexible package using the number format NF as a compile-time variable throughout the code. This often leads to overly specific code whereas a Real would generally suffice. However, this is done to avoid any implicit type conversions.","category":"page"},{"location":"dynamical_core/#Dynamical-core","page":"Dynamical core","title":"Dynamical core","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"A mathematical and implementation-specific description of the dynamical core used in SpeedyWeather.jl","category":"page"},{"location":"dynamical_core/#Mathematical-background","page":"Dynamical core","title":"Mathematical background","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The primitive equations solved by SpeedyWeather.jl are","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\npartial_t u =  \npartial_t v =  \npartial_t T =   \npartial_t Q =  \nendaligned","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"more to come","category":"page"},{"location":"dynamical_core/#Horizontal-diffusion","page":"Dynamical core","title":"Horizontal diffusion","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The horizontal diffusion in SpeedyWeather.jl is implemented as an n-th power Laplacian nabla^2n in spectral space that is applied implicitly.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Given that the spherical harmonics are eigenfunctions of the Laplace operator nabla^2 in spherical coordinates with eigenvalues -l(l+1), applying hyperdiffusion (hyper when n1) can be implemented as a multiplication of the spectral coefficients a_lm with (-l(l+1))^n. For example, vorticity zeta and streamfunction Psi are related by","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta = nabla^2Psi","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Hence, in spectral space this is equivalent for every spectral mode of degree l and order m to","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_lm = frac-l(l+1)R^2Psi_lm","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with R the radius of the sphere (i.e. Earth). It is therefore computationally not more expensive to apply hyperdiffusion as the (-l(l+1))^nR^-2n can be precomputed. In SpeedyWeather.jl the diffusion is applied implicitly. For that, consider a leapfrog scheme with time step Delta t of variable zeta to obtain from time steps i-1 and i, the next time step i+1","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t dzeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with dzeta being some tendency evaluated from zeta_i. Now we want to add a diffusion term -nu nabla^2nzeta with viscosity nu, wich however, is implicitly calculated from zeta_i+1, then","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t (dzeta - nunabla^2nzeta_i+1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"As the application of nunabla^2n is, for every spectral mode, equivalent to a multiplication of a constant, we can rewrite this to","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = fraczeta_i-1 + 2Delta t dzeta1 + 2Delta nunabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and expand the numerator to","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t fracdzeta - nunabla^2nzeta_i-11+2Delta t nu nabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Hence the diffusion can be applied implicitly by updating the tendency dzeta as","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"dzeta to fracdzeta - nunabla^2nzeta_i-11+2Delta t nu nabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"which only depends on zeta_i-1. Now let D_textexplicit = nunabla^2n be the explicit part and D_textimplicit = 1 + 2Delta t nunabla^2n the implicit part. Both parts can be precomputed and are only an element-wise multiplication in spectral space. For every spectral harmonic lm we do","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"dzeta to D_textimplicit^-1(dzeta - D_textexplicitzeta_i-1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Hence 2 multiplications and 1 subtraction with precomputed constants. However, we will normalize the (hyper-)Laplacians as described in the following.","category":"page"},{"location":"dynamical_core/#Normalization-of-diffusion","page":"Dynamical core","title":"Normalization of diffusion","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In physics, the Laplace operator nabla^2 is often used to represent diffusion due to viscosity in a fluid. In that case, the viscosity coefficient is nu of units textm^2texts^-1 and the full operator reads as nu nabla^2 with units (textm^2texts^-1)(textm^-2) = texts^-1. This motivates us to normalize the Laplace operator by a constant of units textm^-2 and the viscosity coefficient by its inverse such that the viscosity coefficient becomes a damping timescale of unit texts^-1. Given the application in spectral space we decide to normalize by the largest eigenvalue l_textmax(l_textmax+1) such that all entries in the discrete spectral Laplace operator are in 01. The normalized viscosity coefficient nu^* = l_textmax(l_textmax+1)nu is therefore reinterpreted as the time scale at which the highest wavenumber is dampened to zero due to diffusion. Together we have ","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"D^textexplicit_lm = nu^* fracl(l+1)l_textmax(l_textmax+1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and the hyper-Laplacian of power n follows as","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"D^textexplicitn_lm = nu^* left(fracl(l+1)l_textmax(l_textmax+1)right)^n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and the implicit part is accordingly D^textimplicitn_lm = 1 + 2Delta t D^textexplicitn_lm.","category":"page"},{"location":"dynamical_core/#Time-integration","page":"Dynamical core","title":"Time integration","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"SpeedyWeather.jl uses a leapfrog time scheme with a Robert's and William's filter to dampen the computational mode and achieve 3rd order accuracy.","category":"page"},{"location":"dynamical_core/#Oscillation-equation","page":"Dynamical core","title":"Oscillation equation","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"fracdFdt = iomega F","category":"page"},{"location":"how_to_run_speedy/#How-to-run-SpeedyWeather.jl","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The simplest way to run SpeedyWeather.jl with default parameters is","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"using SpeedyWeather\nrun_speedy()","category":"page"},{"location":"how_to_run_speedy/#The-run_speedy-interface","page":"How to run SpeedyWeather.jl","title":"The run_speedy interface","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"run_speedy","category":"page"},{"location":"how_to_run_speedy/#SpeedyWeather.run_speedy","page":"How to run SpeedyWeather.jl","title":"SpeedyWeather.run_speedy","text":"prog_vars = run_speedy(NF,kwargs...)\n\nRuns SpeedyWeather.jl with number format NF and any additional parameters in the keyword arguments kwargs.... Any unspeficied parameters will use the default values as defined in src/parameters.jl.\n\n\n\n\n\n","category":"function"},{"location":"parametrizations/#Parameterizations","page":"Parameterizations","title":"Parameterizations","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"This page describes the mathematical formulation of the parameterizations used in SpeedyWeather.jl to represent physical processes in the atmopshere. Every section is followed by a brief description of implementation details.","category":"page"},{"location":"parametrizations/#Convection","page":"Parameterizations","title":"Convection","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Large-scale-condensation","page":"Parameterizations","title":"Large-scale condensation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Clouds","page":"Parameterizations","title":"Clouds","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Short-wave-radiation","page":"Parameterizations","title":"Short-wave radiation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Long-wave-radiation","page":"Parameterizations","title":"Long-wave radiation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Surface-fluxes-of-momentum-and-energy","page":"Parameterizations","title":"Surface fluxes of momentum and energy","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Vertical-diffusion","page":"Parameterizations","title":"Vertical diffusion","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"spectral_transform/#Spherical-Harmonic-Transform","page":"Spherical harmonic transform","title":"Spherical Harmonic Transform","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The following sections outline the implementation of the spherical harmonic transform (in short spectral transform) between the coefficients of the spherical harmonics (the spectral space) and the grid space on a longitude-latitude regular Gaussian grid.","category":"page"},{"location":"spectral_transform/#Inspiration","page":"Spherical harmonic transform","title":"Inspiration","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spectral transform implemented by SpeedyWeather.jl follows largely Justin Willmert's CMB.jl package and makes use of AssociatedLegendrePolynomials.jl and FFTW.jl/FastTransforms.jl for the Fourier transform. Justin described his work in a Blog series [1],[2],[3],[4],[5],[6],[7],[8]","category":"page"},{"location":"spectral_transform/#Spherical-harmonics","page":"Spherical harmonic transform","title":"Spherical harmonics","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spherical harmonics Y_lm of degree l and order m over the longitude theta = (02pi) and latitude phi = (-tfracpi2tfracpi2) (or using colatitudes phi = (0pi)), are","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Y_lm(thetaphi) = lambda_l^m(costheta) e^imphi","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"with lambda_l^m being the pre-normalized associated Legendre polynomials, and e^imphi are the complex exponentials (the Fourier modes). Together they form a set of orthogonal basis functions on the sphere. For an interactive visualisation of the spherical harmonics, see here.","category":"page"},{"location":"spectral_transform/#Synthesis-or-inverse-spectral-transform-(spectral-to-grid)","page":"Spherical harmonic transform","title":"Synthesis or inverse spectral transform (spectral to grid)","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"f(thetaphi) = sum_l=0^l_max sum_m=-l^l a_lm Y_lm(thetaphi)","category":"page"},{"location":"spectral_transform/#Analysis-or-forward-spectral-transform-(grid-to-spectral)","page":"Spherical harmonic transform","title":"Analysis or forward spectral transform (grid to spectral)","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"hata_lm = sum_i=1^N f(theta_iphi_i) Y_lm(theta_iphi_i) sin(theta_i) Delta theta_i Delta phi_i","category":"page"},{"location":"spectral_transform/#Spectral-packing","page":"Spherical harmonic transform","title":"Spectral packing","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Conventional packing lm versus alternative packing lm and arbitrary numbering i.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"| degree l | order m |  l=m |  m=l-m | i | |-|-|-|-|-| |0|0|0|0|1| |1|0|0|1|2| |1|1|1|0|3| |2|0|0|2|4| |2|1|1|1|5| |2|2|2|0|6| |3|0|0|3|7| |...|...|...|...|...|","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Degree l, order m","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"| |m| | | | |-|-|-|-|-| |l|1| | | | | |2|3| | | | |4|5|6| | | |7|8|9|10|","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Alternative packing","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"| |m| | | | |-|-|-|-|-| |l|1|2|4|7| | |3|5|8| | | |6|9| | | | |10| | | |","category":"page"},{"location":"spectral_transform/#Examples","page":"Spherical harmonic transform","title":"Examples","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"julia> using SpeedyWeather\njulia> alms = zeros(ComplexF64,3,3)    # spectral coefficients\njulia> alms[2,2] = 1                   # only l=1,m=1 Legendre polynomial\njulia> map = gridded(alms)             # convert to grid space\n8×4 Matrix{Float64}:\n -0.324541  -0.600363  -0.600363  -0.324541\n -0.134429  -0.248678  -0.248678  -0.134429\n  0.134429   0.248678   0.248678   0.134429\n  0.324541   0.600363   0.600363   0.324541\n  0.324541   0.600363   0.600363   0.324541\n  0.134429   0.248678   0.248678   0.134429\n -0.134429  -0.248678  -0.248678  -0.134429\n -0.324541  -0.600363  -0.600363  -0.324541\n \njulia> spectral(map)                   # back to spectral space\n3×3 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im          0.0+0.0im\n 0.0+0.0im  1.0+3.60727e-17im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im          0.0+0.0im","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"and we have successfully reobtained the l=m=1 spherical harmonic.","category":"page"},{"location":"spectral_transform/#Available-horizontal-resolutions","page":"Spherical harmonic transform","title":"Available horizontal resolutions","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"SpeedyWeather.jl uses triangular truncation such that only spherical harmonics with l leq l_max and m leq m_max are explicitly represented. This is usually described as Tm_max, with l_max = m_max (although in vector quantities require one more degree l in the recursion relation of meridional gradients). For example, T31 is the spectral resolution with l_max = m_max = 31. Note that the degree l and order m are mathematically 0-based, such that the corresponding coefficient matrix is of size 32x32.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Using triangular truncation, there are constraints on the corresponding grid resolution. Let nlon, nlat be the number of longitudes, latitudes on a regular Gaussian grid. Then spectral and grid resolution have to be chosen such that","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nlon geq 3l_max+1\nnlat geq (3l_max+1)2","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"In general, we choose nlon = 2nlat, and ideally nlon is easily Fourier-transformable, e.g. nlon = 2^i3^j5^k with some integers ijk. SpeedyWeather.jl is tested at the following horizontal resolutions","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"l_max nlon nlat\n31 (default) 96 48\n42 128 64\n85 256 128\n170 512 256\n341 1024 512\n682 2048 1024","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Choosing trunc as argument in run_speedy will automatically choose nlon,nlat as presented in the table.","category":"page"},{"location":"spectral_transform/#References","page":"Spherical harmonic transform","title":"References","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[1]: Justin Willmert, 2020. Introduction to Associated Legendre Polynomials (Legendre.jl Series, Part I)  ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[2]: Justin Willmert, 2020. Calculating Legendre Polynomials (Legendre.jl Series, Part II)  ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[3]: Justin Willmert, 2020. Pre-normalizing Legendre Polynomials (Legendre.jl Series, Part III)  ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[4]: Justin Willmert, 2020. Maintaining numerical accuracy in the Legendre recurrences (Legendre.jl Series, Part IV)  ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[5]: Justin Willmert, 2020. Introducing Legendre.jl (Legendre.jl Series, Part V)  ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[6]: Justin Willmert, 2020. Numerical Accuracy of the Spherical Harmonic Recurrence Coefficient (Legendre.jl Series Addendum)  ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[7]: Justin Willmert, 2020. Notes on Calculating the Spherical Harmonics  ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[8]: Justin Willmert, 2022. More Notes on Calculating the Spherical Harmonics: Analysis of maps to harmonic coefficients  ","category":"page"},{"location":"new_model_setups/#New-model-setups","page":"New model setups","title":"New model setups","text":"","category":"section"},{"location":"new_model_setups/","page":"New model setups","title":"New model setups","text":"more to come...","category":"page"},{"location":"#SpeedyWeather.jl-documentation","page":"Home","title":"SpeedyWeather.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SpeedyWeather.jl a global atmospheric circulation model with simple parameterizations to represent physical processes such as clouds, precipitation and radiation.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is a spectral model that uses a Fourier and Legendre transform to calculcate tendencies of the prognostic variables vorticity, divergence, absolute temperature, logarithm of surface pressure and specific humidity. The time stepping uses a leapfrog scheme with additional filters and a semi-implicit formulation for gravity waves. The default resolution is T31 (96x48 grid points on a Gaussian grid, about 400km at the Equator) and 8 vertical levels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple parameterizations are used to represent the physical processes convection, large-scale condensation, clouds, short-wave radiation, long-waves radiation, surface fluxes of momentum and energy, and vertical diffusion.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the following pages of the documentation for more details","category":"page"},{"location":"","page":"Home","title":"Home","text":"How to run SpeedyWeather.jl\nSpherical harmonic transform\nDynamical core\nParametrizations\nNew model setups\nFunction and type index","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the original documentation by Molteni and Kucharski.","category":"page"},{"location":"#Scope","page":"Home","title":"Scope","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The focus of SpeedyWeather.jl is to develop a global atmospheric model of intermediate complexity, that can run at various levels of precision (16, 32 and 64-bit) on different architectures (x86 and ARM, currently planned, GPUs probably in the future). Additionally, the model is written in an entirely number format-flexible way, such that any custom number format can be used and Julia will compile to the format automatically.","category":"page"},{"location":"#History","page":"Home","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is a Julia implementation of SPEEDY, which is written in Fortran 77. Sam Hatfield translated SPEEDY to Fortran 90 and started the project to port it to Julia. However, we are making an effort to overhaul the implementation of the mathematical model behind speedy completely and it is unlikely that a single line of code survived.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is not yet registered in the Julia Registry. So at the moment, open Julia's package manager from the REPL with ] and add the github repository to install SpeedyWeather.jl and all dependencies","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.7) pkg> add https://github.com/milankl/SpeedyWeather.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"other branches can be installed by adding #branch_name, e.g. add https://github.com/milankl/SpeedyWeather.jl#branch_name.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is currently developed by Milan Klöwer and Tom Kipson, any contributions are always welcome.","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is funded by the European Research Council under Horizon 2020 within the ITHACA project, grant agreement number 741112.","category":"page"},{"location":"boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This page describes the formulation of boundary conditions and their implementation.","category":"page"},{"location":"time_integration/#Time-integration","page":"Time integration","title":"Time integration","text":"","category":"section"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"SpeedyWeather.jl uses a leapfrog time scheme with a Robert's and William's filter to dampen the computational mode and achieve 3rd order accuracy.","category":"page"},{"location":"time_integration/#Oscillation-equation","page":"Time integration","title":"Oscillation equation","text":"","category":"section"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"fracdFdt = iomega F","category":"page"},{"location":"time_integration/#Implementation-details","page":"Time integration","title":"Implementation details","text":"","category":"section"}]
}
